# -*- coding: utf-8 -*-
"""Copy of UBCalculation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hlr3TW_CWGWmEJGd-da_RmDuR1sbjCec
"""

Tasks = [[0,10], [2,4], [4,1], [6,1], [9,2]]

def sort(nums, i = 1):
  nums = sorted(nums, key = lambda x : (x[i],x[1-i]))
  return nums

print(sort(Tasks, 1))

def UBcalcul(tasks):
  current_time = 0
  somme_Ci = 0
  tasks = sort(tasks)
  while(tasks != []):
    current_task = [x for x in tasks if x[0] <= current_time]
    if current_task != []:
      current_time += current_task[0][1]
      somme_Ci += current_time
      tasks.remove(current_task[0])
    else:
      current_time = min(tasks)[0]
  return somme_Ci

print(UBcalcul(Tasks))

def LBcalcul(tasks):
  current_time = 0
  somme_Ci = 0
  #on trie les tâches selon les ri
  tasks = sort(tasks, 0)
  available_tasks = []

  while(tasks != [] or available_tasks != []): #condition car tasks va se vider mais available tasks va avoir la dernière tâche à faire

    #ajout des tâches disponibles à available_tasks
    while(tasks != [] and tasks[0][0] <= current_time):
      available_tasks.append(tasks.pop(0))

    #trie de available_tasks par ps
    available_tasks = sort(available_tasks)


    if available_tasks != []:
      #vérification si la tâche a finie
      if available_tasks[0][1] == 0:
        #élimination du tâche et ajoute de sont Ci à notre somme
        available_tasks.pop(0)
        somme_Ci += current_time
    if available_tasks != []:
      available_tasks[0][1] -= 1

    current_time +=1
  return somme_Ci

print(LBcalcul(Tasks))